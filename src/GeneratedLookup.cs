using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace GeneratedLookup;

[AttributeUsage(AttributeTargets.Method, AllowMultiple = false)]
public sealed class GeneratedLookupAttribute<T> : Attribute
{
    public GeneratedLookupAttribute(string[] keys, T[] values)
    {
        if (keys.Length != values.Length)
            throw new InvalidOperationException($"Validation failed: {keys.Length} != {values.Length}");
    }
}

[Generator]
public sealed class GeneratedLookup : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Create a syntax provider to track methods with a specific attribute
        IncrementalValuesProvider<(IMethodSymbol Symbol, AttributeData Attr)> methodDeclarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (s, _) => s is MethodDeclarationSyntax method &&
                    method.AttributeLists.SelectMany(a => a.Attributes).Any(a => a.Name.ToString().StartsWith("GeneratedLookup")),
                transform: static (ctx, _) =>
                {
                    if (ctx.SemanticModel.GetDeclaredSymbol(ctx.Node) is not IMethodSymbol symbol)
                        throw new InvalidOperationException("Unable to determine method symbol.");

                    AttributeData attr = symbol.GetAttributes().FirstOrDefault(a =>
                        a.AttributeClass?.Name.StartsWith("GeneratedLookup") == true) ??
                        throw new InvalidOperationException("Unable to determine attribute.");

                    return (Symbol: symbol, Attr: attr);
                });

        // Register source output generation for each matching method
        context.RegisterSourceOutput(methodDeclarations, GenerateLookupMethod);
    }

    private static void GenerateLookupMethod(SourceProductionContext context, (IMethodSymbol symbol, AttributeData attr) data)
    {
        // Extract the keys and values from the attribute constructor arguments
        IEnumerable<string> keys = data.attr.ConstructorArguments[0].Values
            .Select(v => v.Value as string ?? throw new InvalidOperationException("Key cannot be null."));
        IEnumerable<object> vals = data.attr.ConstructorArguments[1].Values
            .Select(v => v.Value ?? throw new InvalidOperationException("Value cannot be null."));
        INamedTypeSymbol attributeClass = data.attr.AttributeClass
            ?? throw new InvalidOperationException("Unable to determine attribute class name.");
        string valType = attributeClass.TypeArguments[0].ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat);

        // Sort keys and values by key length
        IOrderedEnumerable<(string Key, object Val, int Index)> ordered = keys
            .Select((k, i) => (Key: k, Val: vals.ElementAt(i), Index: i))
            .OrderBy(kv => kv.Key.Length);

        // Concatenate all the keys together for lookup
        string keysConcat = string.Concat(ordered.Select(kv => kv.Key));

        // Generate offsets and key lengths
        List<int> keyOffsets = new();
        List<int> keyLengths = new();
        int offset = 0;
        foreach ((string key, _, _) in ordered)
        {
            keyOffsets.Add(offset);
            keyLengths.Add(key.Length);
            offset += key.Length;
        }

        // Get the raw attribute syntax
        SyntaxReference syntaxRef = data.attr.ApplicationSyntaxReference
            ?? throw new InvalidOperationException("Unable to obtain attribute syntax.");
        if (syntaxRef.GetSyntax() is not AttributeSyntax attributeSyntax)
            throw new InvalidOperationException("Unable to obtain attribute syntax reference.");
        AttributeArgumentListSyntax argumentList = attributeSyntax.ArgumentList
            ?? throw new InvalidOperationException("Unable to obtain argument list.");

        // Get the unsorted CollectionExpressionSyntax for values
        CollectionExpressionSyntax valueExpr = argumentList.Arguments[1].Expression as CollectionExpressionSyntax
            ?? throw new InvalidOperationException("Second argument is not a collection expression.");

        // Sort the value elements by the same order used for the keys
        string sortedValuesSource = string.Join(", ",
            ordered.Select(o => valueExpr.Elements[o.Index].ToFullString())
        );

        // Build source
        context.AddSource($"Generated_{data.symbol.Name}.g.cs", SourceText.From($$"""
        // <auto-generated />
        using System;
        {{(data.symbol.ContainingNamespace.ToString() == "<global namespace>" ? string.Empty : $"\nnamespace {data.symbol.ContainingNamespace};\n")}}
        public static partial class {{data.symbol.ContainingType.Name}}
        {
            public static partial bool {{data.symbol.Name}}(ReadOnlySpan<char> key, out {{valType}} value)
            {
                if (key.Length == 0)
                {
                    value = default;
                    return false;
                }

                // Concatenated keys and associated metadata
                ReadOnlySpan<char> keysConcat = "{{keysConcat}}";
                ReadOnlySpan<int> keyOffsets = [{{string.Join(", ", keyOffsets)}}];
                ReadOnlySpan<int> keyLengths = [{{string.Join(", ", keyLengths)}}];
                ReadOnlySpan<{{valType}}> values = [{{sortedValuesSource}}];

                int searchStart = 0;
                while (true)
                {
                    int foundOffset = searchStart + keysConcat[searchStart..].IndexOf(key);
                    if (foundOffset < 0)
                    {
                        value = default;
                        return false;
                    }

                    int keyIndex = keyOffsets.IndexOf(foundOffset);
                    if (key.Length != keyLengths[keyIndex])
                    {
                        if (keyIndex + 1 >= keyOffsets.Length)
                        {
                            value = default;
                            return false;
                        }

                        searchStart = keyOffsets[keyIndex + 1];
                        continue;
                    }

                    value = values[keyIndex];
                    return true;
                }
            }
        }
        """, Encoding.UTF8));
    }
}
